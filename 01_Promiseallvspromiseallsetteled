Code samples -
__________________

ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—¹ğ—¹() ğ˜ƒğ˜€ ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—¹ğ—¹ğ—¦ğ—²ğ˜ğ˜ğ—¹ğ—²ğ—±() ğ˜ƒğ˜€ ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—¿ğ—®ğ—°ğ—²() ğ˜ƒğ˜€ ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—»ğ˜†()ğŸ˜€

ğŸ­.ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—¹ğ—¹()-
Promise.all() takes an array of promises and returns a single promise that resolves when all of the input promises have resolved.

ğ—–ğ—¼ğ—±ğ—²-

const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 500);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     resolve("promise 2 is resolved")
   }, 1000);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 2000);
})

Promise.all([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))

ğ—¢ğ˜‚ğ˜ğ—½ğ˜‚ğ˜-

[ 'promise 1 resolved', 'promise 2 resolved', 'promise 3 resolved' ]

â€”â€”â€”â€”â€”

If any of the promise reject, Promise.all() will reject immediately with the reason of the first promise that rejects.
ğ—–ğ—¼ğ—±ğ—²-
const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 500);
})

const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     reject("promise 2 is rejected")
   }, 1000);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 2000);
})


Promise.all([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))

ğ—¢ğ˜‚ğ˜ğ—½ğ˜‚ğ˜ğ˜€ -

promise 2 is rejected

_________________________

ğŸ®.ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—¹ğ—¹ğ—¦ğ—²ğ˜ğ˜ğ—¹ğ—²ğ—±()-

Promise.allSettled() returns a promise that resolves when all input promises have settled (either resolved or rejected), and it gives you the results of all promises.


Use Case: When you want to wait for all promises to finish (whether they succeed or fail) and you want to know the outcome of each.


const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 500);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     resolve("promise 2 is resolved")
   }, 1000);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 2000);
})


Promise.allSettled([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))



Output -

Array of object-
Has status and value field keys

[
  { status: 'fulfilled', value: 'promise 1 resolved' },
  { status: 'fulfilled', value: 'promise 2 is resolved' },
  { status: 'fulfilled', value: 'promise 3 resolved' }
]

________________________________________

In case any of the promise is rejected-

const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 500);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     reject("promise 2 is rejected")
   }, 1000);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 2000);
})


Promise.allSettled([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))


Output -

[
  { status: 'fulfilled', value: 'promise 1 resolved' },
  { status: 'rejected', reason: 'promise 2 is rejected' },
  { status: 'fulfilled', value: 'promise 3 resolved' }
]

____________________

ğŸ¯.ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—¿ğ—®ğ—°ğ—²() -


Promise.race() takes an array of promises and returns a promise that resolves or rejects as soon as the first promise resolves or rejects.
It only cares about the first promise to resolve or reject, and ignores the others.


const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 800);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     reject("promise 2 is rejected")
   }, 300);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 1000);
})


Promise.race([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))


Output -

promise 2 is rejected


___________________

ğŸ°.ğ—½ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—»ğ˜†()-

Promise.any() takes an array (or iterable) of promises and returns a promise that resolves as soon as any of the input promises resolves.

const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 800);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     resolve("promise 2 is resolved")
   }, 300);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 1000);
})


Promise.any([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))



Output -

promise 2 is resolved


______________

ğ—œğ—» ğ—°ğ—®ğ˜€ğ—² ğ—¼ğ—³ ğ—®ğ—»ğ˜† ğ—½ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—² ğ—¶ğ˜€ ğ—¿ğ—²ğ—·ğ—²ğ—°ğ˜ğ—²ğ—±, ğ—¶ğ˜ ğ˜€ğ˜ğ—¶ğ—¹ğ—¹ ğ˜€ğ—µğ—¼ğ˜„ğ˜€ ğ˜ğ—µğ—² ğ—³ğ—¶ğ—¿ğ˜€ğ˜ ğ—¿ğ—²ğ˜€ğ—¼ğ—¹ğ˜ƒğ—²ğ—± ğ—¼ğ—»ğ—²-

const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 1 resolved");
   }, 800);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     reject("promise 2 is rejected")
   }, 300);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      resolve("promise 3 resolved");
   }, 1000);
})


Promise.any([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))



Output-

Promise 1 is resolved 
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

If all Promise  reject then  it rejects with an AggregateError.


const promise1 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      reject("promise 1 rejcted");
   }, 800);
})
const promise2 = new Promise((resolve, reject) =>{
   setTimeout(() => {
     reject("promise 2 is rejected")
   }, 300);
})

const promise3 = new Promise((resolve, reject) =>{
   setTimeout(() => {
      reject("promise 3 reject");
   }, 1000);
})


Promise.any([promise1,promise2,promise3])
.then(res =>  console.log(res))
.catch(ex => console.log(ex))

Output-

[AggregateError: All promises were rejected] {
  [errors]: [ 'promise 1 rejcted', 'promise 2 is rejected', 'promise 3 reject' ]
}


___________________


ğ—ğ—²ğ˜† ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—²ğ˜€
* ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—¹ğ—¹(): Resolves when all promises resolve, rejects if any promise rejects.
* ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—¹ğ—¹ğ—¦ğ—²ğ˜ğ˜ğ—¹ğ—²ğ—±(): Resolves when all promises settle (either resolve or reject) and provides information about each promise.
* ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—®ğ—»ğ˜†(): Resolves when the first promise resolves, rejects if all promises reject.
* ğ—£ğ—¿ğ—¼ğ—ºğ—¶ğ˜€ğ—².ğ—¿ğ—®ğ—°ğ—²(): Resolves or rejects as soon as the first promise resolves or rejects.


